#!/usr/bin/env ruby
#
$:.unshift("lib")
require 'storage/servers'
require 'thor'

module CLI
  include ClusterMan
  CONNSTRING = "sqlite://servers.sql"

  class DB < Thor
    desc "update", "Update the servers database schema"
    def update
      ClusterMan.migrate(CONNSTRING, "migrations")
    end
  end

  class Server < Thor
    desc "add", "Add a list of servers described in YAML from STDIN"
    option :client, :banner => "Client name"
    def add
      require 'yaml'
      serverlist = Array(YAML.load($stdin.read))

      store = ClusterMan::Persistence::Server.new(CONNSTRING)

      defaults = {:client => options[:client]}

      serverlist.each do |server|
        store.insert_or_update(defaults.merge(server))
      end
    end

    desc "list", "List servers that Clusterman knows about"
    def list
      puts ClusterMan::Queries::Server.new(CONNSTRING).print
    end
  end

  class Main < Thor
    class << self
      def required_options(*options)
        options.each do |name|
          option name, :required => true
        end
      end
      alias required_option required_options
    end


    desc "db SUBCOMMAND", "server database maintenance tasks"
    subcommand "db", DB

    desc "server SUBCOMMAND", "server listing tasks"
    subcommand "server", Server

    class_option :client
    class_option :name
    class_option :role

    class CommandDefinition
      SCOPE_TO_OPTIONS = {
        "all" => [],
        "client" => [:client],
        "role" => [:client, :role],
        "name" => [:client, :name]
      }
      attr_accessor :name, :description, :scope
      attr_reader :action

      alias desc= description=

      def initialize(name=nil, scope=nil, desc=nil)
        @name = name
        @description = desc
        @scope = scope
      end

      def action(&block)
        if block_given?
          @action = block
        else
          @action
        end
      end

      def valid?
        return false if @name.nil?
        return false unless SCOPE_TO_OPTIONS.keys.include? @scope.to_s
        return false if @action.nil?
        return true
      end

      def scope_options
        SCOPE_TO_OPTIONS[@scope.to_s]
      end
    end

    def self.define_from(config)
      unless config.valid?
        raise "Invalid command definition: #{config.inspect}"
      end

      desc config.name.to_s, config.description
      config.scope_options.each do |option|
        required_option option
      end

      define_method config.name do
        ClusterMan::CommandConfig.go!(CONNSTRING) do |cmd|
          cmd.servers(options || {})
          cmd.instance_eval(&config.action)
        end
      end
    end

    def self.register_command
      config = CommandDefinition.new
      yield config

      define_from(config)
      nil
    end

    def self.quick_register(name, scope, desc, &block)
      register_command do |config|
        config.name = name
        config.scope = scope
        config.description = desc
        config.action(&block)
      end
    end
  end
end

CLI::Main.register_command do |config|
  config.name = :query_load
  config.scope = :all
  config.desc = "Check the load on multiple servers"

  config.action do
    ssh "uname -a; uptime"
  end
end

CLI::Main.start(ARGV)
